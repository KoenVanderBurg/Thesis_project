---
title: "pipeline_set_1"
author: "Koen van der Burg"
date: '2022-07-05'
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(devtools)
library(ggbiplot)
library(readxl)
library(ggplot2)
library(tidyverse)
library(RColorBrewer)
library(DEGreport)
library(ggrepel)
library(readxl)
library(IHW)
library(pheatmap)
library(EnhancedVolcano)
library(DESeq2)
library(Glimma)
library(tidyr)
library(ComplexHeatmap)
library(clusterProfiler)
library(enrichplot)
library(R.utils)
library(DOSE)

R.utils::setOption("clusterProfiler.download.method","auto")

#Select organism
organism = "org.Hs.eg.db"
library(organism, character.only = TRUE)
```

# Quality Control

```{r, echo = FALSE, include=FALSE}

  setwd("C:/Users/koenv/OneDrive/Documenten/Universiteit/Bio-informatica Jaar 3/Thesis_project/input_data")
  #Loading in files
  sample_sheet <- read_excel("sample_sheet.xlsx")
  CRC_dataset <- read_excel("CRC_Stage-III_Salzburg-Cohort_Coded_Relapse-Data_fChristina.xlsx")

  #Merging two tables together, based on sample_ID/samplegetwd()\
  full_data <- merge (sample_sheet, CRC_dataset, by.x = "sample", by.y = "Sample ID")
  
  #Select the columns that we want to keep
  full_data =  subset(full_data, select = c("sample", "Sex\n[1=male; 2=female]", "Relapse within 3 years\n[0=No; 1=Yes]","Tumor Cell Content\n[minimum]","Tumor Cell Content\n[maximum]"))
  
  #Changing the column names for easier viewing
  colnames(full_data) <- c('sample','gender', 'response', 'min_tumor_cell_content','max_tumor_cell_content')
  
  #Remove spaces from sample column of the df table.
  full_data$sample <- gsub('\\s+', '', full_data$sample)
  
  #Creating a filter that shows us a minimum tumor cell content of either 50% or 25%.
  vars <- c("min_tumor_cell_content")
  cond <- c(50, 25)
  
  #Using the filter, can select the condition (50%,25%) for which we want to check.
  annotation_table <- full_data %>% filter(.data[[vars[[1]]]] >= cond[[1]])
  
  #write.table(annotation_table, file="Annotation_table", quote = F)
  
  #loading in gene count data set
  counts_table <- read_table("salmon.merged.gene_counts.tsv")
  
  #optimized viewing (removing _ from the gene count data set)
  colnames(counts_table) <- gsub("_", "", colnames(counts_table))
  
  #removing samples from gene_count_dataset that don't have the 50% tumor cell count
  counts_table <- subset(counts_table, select = c("geneid","genename", annotation_table$sample))
  
  #creating a sum of all the gene counts
  counts_table_sum <- counts_table[annotation_table$sample]
  counts_table_sum <- lapply(counts_table_sum, sum, 2)
  counts_table_sum <- t(as.data.frame(counts_table_sum))
  
  
  #bar plot for total counts_table_sum:
    #-remove samples that have a count below 200.000
  counts_table_sum <- counts_table_sum[counts_table_sum[, 1] >= 200000, ]
  counts_table_sum <- as.data.frame(counts_table_sum) 
  colnames(counts_table_sum) <- c("total_counts")



```

## Total count numbers

Barplot of total count for each of the samples. Samples have at least 200.00 counts over all the genes and contain at least 50% tumor cell content.

```{r barplot, echo = FALSE}
#Actual plotting of the barplot
gene_barplot <- ggplot(data = counts_table_sum)+ geom_bar(mapping = aes(x= reorder(rownames(counts_table_sum), -total_counts), y = total_counts), stat = "identity")
gene_barplot <- gene_barplot + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
gene_barplot + labs(y="Counts", x = "Samples")

```

## Tumor cell content

In this barplot the minimum tumor cell content is showed for all the samples.

```{r, echo=FALSE, include=FALSE}

#Filter out needed columns
response_df <- subset(annotation_table, select = c ("sample", "response", "min_tumor_cell_content"))
colnames(response_df) <- c("sample", "response", "min_tumor_cell_content")
response_df$response <- as.character(response_df$response)
response_df$response <- recode(response_df$response,"1" = " No Relapse", "0" = "Relapse")

#sub-setting out samples with the lower counts
response_df <- response_df[response_df$sample %in% rownames(counts_table_sum),]

```

```{r Tumor cell content, echo=FALSE}
#Actual plotting of response barplot
response_barplot <- ggplot(data = response_df)+
  geom_bar(mapping = aes(x = reorder(sample, -min_tumor_cell_content), y = min_tumor_cell_content, fill = response), stat = "identity")
response_barplot <- response_barplot + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs (y = "Min tumor cell content", x = "Samples") +
  scale_fill_discrete(name = "Relapse", labels = c("Relapse", "No relapse"))

response_barplot
```

## PCA plotting

PCA plot to see if the two groups (relapse / no relapse) could be separated by PC1 and PC2. Sadly the two groups could not be separated as seen by the ellipses.

```{r, echo=FALSE, include=FALSE}
#PCA plotting

#Removing samples <200.000
t_counts_table <- t(counts_table)
t_counts_table <- t_counts_table[rownames(t_counts_table) %in% rownames(counts_table_sum),]

counts_table <- counts_table
counts_table <- as.data.frame(counts_table[,-2])
rownames(counts_table) <- counts_table$geneid
counts_table <- counts_table[,-1]

counts_table <- t(counts_table)
counts_table <- as.data.frame(counts_table[rownames(counts_table) %in% rownames(t_counts_table),])
counts_table <- log(counts_table+1)
```

```{r PCA plot, echo = FALSE}
  
counts.pca <- prcomp(counts_table) # center =TRUE, scale. = TRUE)
ggbiplot(counts.pca, var.axes = FALSE, groups = response_df$responseAs, ellipse = TRUE, )

```

# DE analysis

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

## Reading in tables and modifying them
```{r CRC_loading,message=FALSE, warning=FALSE}
setwd("C:/Users/koenv/OneDrive/Documenten/Universiteit/Bio-informatica Jaar 3/Thesis_project/input_data")

#reading in Counts_table (>50% > 200.000)
CRC_counts_table <- read.table("Counts_table_DeSeq")
CRC_annotation <- read.table("Annotation_table")
CRC_counts_table_gene <- read.table("salmon.merged.gene_counts.tsv") 

#modifying annotation table
CRC_annotation$gender <-  recode(CRC_annotation$gender,"1" = "Male", "2" = "Female")
CRC_annotation$response <- recode(CRC_annotation$response, "0" = "No_relapse", "1" = "Relapse")
CRC_annotation <- CRC_annotation[CRC_annotation$sample %in% colnames(CRC_counts_table),]                #removal samples that don't have 200.000 counts
CRC_annotation <- data.frame(CRC_annotation, row.names = CRC_annotation$sample)                         #set row_names -> sample names
CRC_annotation <- subset(CRC_annotation, select = c(response,gender,min_tumor_cell_content))            #removal sample column

#remove genes that have <2 total count in row
CRC_counts_table <- cbind(CRC_counts_table, total = rowSums(CRC_counts_table))                          #create column with total row_counts
CRC_counts_table <- subset(CRC_counts_table, total > 1)                                                 #remove rows(genes) with less than 2 counts
CRC_counts_table <- subset(CRC_counts_table, select = -(total))                                         #removal total column

#ensemble version removal and removal of PAR_Y genes.
CRC_counts_table = CRC_counts_table[!grepl("_Y$",rownames(CRC_counts_table)),]                          #remove rows that end with the PAR_Y gene_id
CRC_counts_table$row_names <- row.names(CRC_counts_table)                                               #set row_names to column_names
CRC_counts_table$row_names <- gsub('(\\.).*', '', CRC_counts_table$row_names)                           #change row_names by removing ensemble ID
CRC_counts_table <- as.data.frame(CRC_counts_table, row.names = CRC_counts_table$row_names)             #convert back to original state
CRC_counts_table <- subset(CRC_counts_table, select = -(row_names))                                     #removal of row_names column
CRC_counts_table <- as.matrix(round(CRC_counts_table, 0))                                               #rounding counts to remove decimals
```


## Pre-check DESeq2 
```{r check, results='hide',message=FALSE, warning=FALSE}

#check if samples both in counts_table and annotation table, and amount of samples is equal.
table(colnames(CRC_counts_table) %in% rownames(CRC_annotation)) 
table(colnames(CRC_counts_table) == rownames(CRC_annotation))

```

## Creating DESeq2 object
Creating a DESeq2 object, from here we create a normalized counts table. The created dds object which is used later on for PCA plotting and heat map.
```{r normalized_counts,message=FALSE, warning=FALSE}

#creating DESeq2Dataset object and normalized_counts file.
dds <- DESeqDataSetFromMatrix(countData = round(CRC_counts_table), colData = CRC_annotation, design = ~ response)
dds <- estimateSizeFactors(dds)                                                                         #median of ratios method of normalization
normalized_counts <- counts(dds, normalized=TRUE)                                                       #retrieving normalized counts matrix


#interactive plotting
#glimmaMDS(dds)         


#creation of normalized_counts file
#write.table(normalized_counts, file="normalized_counts.txt", sep="\t", quote=F, col.names=NA, file.path ("C:/Users/koenv/OneDrive/Documenten/Universiteit/Bio-informatica Jaar 3/Thesis_project/output_data"))  

```


## PCA plots and correlation heatmap
Coloring on heat map needs to be changed. 
```{r QC,message=FALSE, warning=FALSE}

rld <- vst(dds, blind=TRUE)                                                                         #transform counts for data visualization.
 
plotPCA(rld, intgroup="response")                                                                   #PCA plot: Response    
plotPCA(rld, intgroup="gender")                                                                     #PCA plot: Gender
plotPCA(rld, intgroup= "min_tumor_cell_content")                                                    #PCA plot: Min tumor cell

##Heatmap
rld_mat <- assay(rld)                                                                               #extract the r-log matrix from the object
rld_cor <- cor(rld_mat)                                                                             #compute pairwise correlation values
CRC_annotation_heatmap <- subset(CRC_annotation, select = (response))                               
pheatmap(rld_cor, annotation_col = CRC_annotation_heatmap, main = "Pairwise correlation values", )  #plot heat map using the correlation matrix + metadata object
```

## DESeq2 analysis
Running the DESeq2 analysis, results derived from Independent Hypothesis Testing (IHW), using a log fold shrinkage. 
```{r DESeq2,message=FALSE, warning=FALSE}
dds <- DESeq(dds) 
resIHW_unshrunken <- results(dds, filterFun = ihw)                                               #extracting results using IHW
resIHW <- lfcShrink(dds, coef= "response_Relapse_vs_No_relapse" , type = "normal")               #applying log fold change shrinkage
```

## Dispersion and MA plots
```{r MAplot,message=FALSE, warning=FALSE}
#Plot dispersion estimates
plotDispEsts(dds, main = "Dispersion plot")

#MA Plot, colored genes are identified as significantly DE
plotMA(resIHW_unshrunken, ylim=c(-2,2), main = "Unshrunken MA plot")                                              
plotMA(resIHW, ylim=c(-2,2), main = "LFC MA plot")                                                                

```

## Significant DE genes
The DE genes are cut-off at a adjusted p-value of 0.1 and a log2FoldChange of 1.
```{r sig_genes,message=FALSE, warning=FALSE}

#Creating a tibble of the results
resIHW_tb <- resIHW %>% data.frame() %>% rownames_to_column(var="gene_id") %>% as_tibble()

#Setting thresholds
padj.cutoff <- 0.05                                                                                               
log2FoldChange.cutoff.down <- -1 
log2FoldChange.cutoff.up <- 1

#Subset the tibble to keep only DEG's 
sigIHW_down <- resIHW_tb %>%                                                                   #selection of down_regulated genes
  filter(log2FoldChange < log2FoldChange.cutoff.down) %>%
  filter(padj < padj.cutoff)
sigIHW_up <- resIHW_tb %>%                                                                     #selection of up_regulated genes
  filter(log2FoldChange > log2FoldChange.cutoff.up) %>%
  filter(padj < padj.cutoff)

sigIHW <- rbind(sigIHW_down,sigIHW_up)                                                         #selection of both up and down regulated genes 
rownames(sigIHW) <- sigIHW$gene_id

#Getting significant DE gene list + log2foldchange
colnames(CRC_counts_table_gene) <- CRC_counts_table_gene[1,]
CRC_counts_table_gene <- CRC_counts_table_gene[-1,]
CRC_counts_table_gene$gene_id <- gsub('(\\.).*', '', CRC_counts_table_gene$gene_id)            #Change row_names by removing ensembl ID
CRC_gene <- subset(CRC_counts_table_gene, select = c(gene_id, gene_name))
CRC_gene_sub <- CRC_gene[CRC_gene$gene_id %in% rownames(sigIHW),]
sigIHW <- cbind(sigIHW, gene_name = CRC_gene_sub$gene_name)
sigIHW <- subset(sigIHW, gene_id != "ENSG00000276778")                                         #Metazoa_SRP change removal
sigIHW <- subset(sigIHW, gene_id != "ENSG00000277270")                                                            
sigIHW <- subset(sigIHW, select = c(log2FoldChange,gene_id, gene_name))


write.csv(sigIHW_down,sep=" ", quote=F, col.names=NA, file.path("C:/Users/koenv/OneDrive/Documenten/Universiteit/Bio-informatica Jaar 3/Thesis_project/output_data", "sigIHW_down.csv"))

write.csv(sigIHW_up,sep=" ", quote=F, col.names=NA, file.path("C:/Users/koenv/OneDrive/Documenten/Universiteit/Bio-informatica Jaar 3/Thesis_project/output_data", "sigIHW_up.csv"))


```   

## Significant DE genes (unshrunken)
The DE genes are cut-off at a adjusted p-value of 0.1 and a log2FoldChange of 1. Here we used the unshrunken results of the genes. This results in more DE genes. 

```{r sig_genes_unshrunken,message=FALSE, warning=FALSE}

#Creating a tibble of the un-shrunken results
resIHW_tb_unshrunken <- resIHW_unshrunken %>%   data.frame() %>%   rownames_to_column(var="gene_id")%>%   as_tibble()

#Setting thresholds
padj.cutoff <- 0.05
log2FoldChange.cutoff.down <- -1 
log2FoldChange.cutoff.up <- 1

#Subset the tibble to keep only DEG's 
sigIHW_down_unshrunken <- resIHW_tb_unshrunken %>%
  filter(log2FoldChange < log2FoldChange.cutoff.down) %>%
  filter(padj < padj.cutoff)
sigIHW_up_unshrunken <- resIHW_tb_unshrunken %>%
  filter(log2FoldChange > log2FoldChange.cutoff.up) %>%
  filter(padj < padj.cutoff)

sigIHW_unshrunken <- rbind(sigIHW_down_unshrunken,sigIHW_up_unshrunken)
rownames(sigIHW_unshrunken) <- sigIHW_unshrunken$gene_id

#Getting significant DE gene list + applying log2foldchange
CRC_gene_sub <- CRC_gene[CRC_gene$gene_id %in% rownames(sigIHW_unshrunken),]
sigIHW_unshrunken <- cbind(sigIHW_unshrunken, gene_name = CRC_gene_sub$gene_name)

#row.names(sigIHW_unshrunken) <- sigIHW_unshrunken$gene_name                                                        #‘Metazoa_SRP’, ‘Y_RNA’ duplicates
sigIHW_unshrunken <- subset(sigIHW_unshrunken, select = c(log2FoldChange,gene_id,gene_name))




```   

## Volcano plotting
```{r Volcano_plotting, fig.height=10, fig.width=10,message=FALSE, warning=FALSE }

resIHW_join <- merge (x = CRC_gene, y= resIHW_tb, by= "gene_id")
resIHW_join_unshrunken <- merge (x = CRC_gene, y = resIHW_tb_unshrunken, by= "gene_id")

EnhancedVolcano(resIHW_join,
                lab = resIHW_join$gene_name,
                x = 'log2FoldChange',
                y = 'padj',
                ylim = c(0,8),
                drawConnectors = TRUE,
                pCutoff = 0.05, 
                FCcutoff = 1
                )


EnhancedVolcano(resIHW_join_unshrunken,
                lab = resIHW_join_unshrunken$gene_name,
                x = 'log2FoldChange',
                y = 'padj',
                ylim = c(0,8),
                drawConnectors = TRUE,
                pCutoff = 0.05, 
                FCcutoff = 1
                )
```


## DE genes heatmap
Need to change the colors of to top_annotation. 
```{r Heatmap,message=FALSE, warning=FALSE}
setwd("C:/Users/koenv/OneDrive/Documenten/Universiteit/Bio-informatica Jaar 3/Thesis_project/input_data")
normalized_counts <- read.table("normalized_counts.txt")                                                #load in normalized_counts
normalized_counts <- cbind(normalized_counts, gene_id = row.names(normalized_counts))                             
normalized_counts <- merge (x = CRC_gene, y= normalized_counts, by= "gene_id")                          #merge dataframes by gene_id
normalized_counts <- normalized_counts[normalized_counts$gene_id %in% sigIHW$gene_id ,]                 #select significant genes
normalized_counts <- subset(normalized_counts, gene_id != "ENSG00000274701")                            #Metazoa_SRP change removal
normalized_counts <- subset(normalized_counts, gene_id != "ENSG00000277250")              
row.names(normalized_counts) <- normalized_counts$gene_name
normalized_counts <- subset(normalized_counts, select = -c(gene_id, gene_name))                         #remove gene_id and gene_name
normalized_counts <- t(scale(t(normalized_counts)))                                                     #scaling and transposing normalized_counts

Heatmap(normalized_counts,name = "Z-score", show_row_names = FALSE, cluster_rows = FALSE,                   
        top_annotation = HeatmapAnnotation("Response" = CRC_annotation$response))                       #plotting the heat-map
```

---
title: "GO analysis"
author: "Koen van der Burg"
date: "19/05/2021"
output: html_document
editor_options: 
chunk_output_type: inline
---
  
# GO Analysis
  
## Setup library

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```


```{r loading dataframe and prepare input, echo = FALSE, include = FALSE}
setwd("C:/Users/koenv/OneDrive/Documenten/Universiteit/Bio-informatica Jaar 3/Thesis_project/output_data")
#sig_down <- read.csv("sigIHW_down.csv", head= TRUE,)
#sig_down <- data.frame(sig_down, row.names = sig_down$gene_id)                  
#sig_down <- subset(sig_down, select = -(gene_id))  

#write.csv(sig_down,sep="\t", quote=F, col.names=NA, file.path ("C:/Users/koenv/OneDrive/Documenten/Universiteit/Bio-informatica Jaar 3/Thesis_project/output_data"), "sigIHW_down.csv")

sig_down <- read.csv("sigIHW_down.csv", header = TRUE)
sig_up <- read.csv("sigIHW_up.csv", header = TRUE)
sig_gene <- rbind(sig_down, sig_up)


original_gene_list <- sig_gene$log2FoldChange                                          
names(original_gene_list) <- sig_gene$gene_id                                    #name the vector
gene_list<-na.omit(original_gene_list)                                          #omit any NA values 
gene_list = sort(gene_list, decreasing = TRUE)                                  #sort the list in decreasing order (required for clusterProfiler)

```

```{r Gene set Enrichtment, echo= FALSE, include= FALSE}

gse <- gseGO(geneList=gene_list, 
             ont ="ALL", 
             keyType = "ENSEMBL", 
             minGSSize = 3, 
             maxGSSize = 800, 
             pvalueCutoff = 0.05, 
             verbose = TRUE, 
             OrgDb = org.Hs.eg.db, 
             pAdjustMethod = "none")

```
 

```{r Enrichment Map, warning= FALSE, message = FALSE}
#Enrichment analysis plots
dotplot(gse, showCategory=9, split=".sign") + facet_grid(.~.sign)
cnetplot(gse, categorySize="pvalue", foldChange=gene_list, showCategory = 3, cex_label_gene = 0.75, cex_label_category = 0.75)
ridgeplot(gse) + labs(x = "enrichment distribution") + theme(axis.text.y = element_text(size = 5))

compare_cluster_GO_emap <- enrichplot::pairwise_termsim(gse, semData = gse)
emapplot(compare_cluster_GO_emap, showCategory = 10)

```





```{r Prepare input KEGG, echo= FALSE, include=FALSE}
#convert gene IDs for gseKEGG function, lose some genes here because not all IDs will be converted
ids<-bitr(names(original_gene_list), fromType = "ENSEMBL", toType = "ENTREZID", OrgDb= "org.Hs.eg.db")

#remove duplicate IDS (here I use "ENSEMBL", but it should be whatever was selected as keyType)
ids = ids[!duplicated(ids[c("ENSEMBL")]),]

#create a new dataframe mapped_genes which has only the genes which were successfully mapped using the bitr function above
mapped_genes = sig_down[sig_down$gene_id %in% ids$ENSEMBL,]
ids = ids[ids$ENSEMBL %in% mapped_genes$gene_id,]

#create a new column in mapped_genes with the corresponding ENTREZ IDs
mapped_genes$Y = ids$ENTREZID

#create a vector of the gene unuiverse
kegg_gene_list <- mapped_genes$log2FoldChange

#cnme vector with ENTREZ ids
names(kegg_gene_list) <- mapped_genes$Y

#omit any NA values 
kegg_gene_list<-na.omit(kegg_gene_list)

#sort the list in decreasing order (required for clusterProfiler)
kegg_gene_list = sort(kegg_gene_list, decreasing = TRUE)

```

```{r Create gseKEGG object, echo=FALSE, include=FALSE}
KEGG <- gseKEGG(geneList     = kegg_gene_list,
               organism     = "hsa",
               minGSSize    = 0,
               maxGSSize    = 800,
               pvalueCutoff = 0.5,
               pAdjustMethod = "none",
               keyType       = "ncbi-geneid")
```

```{r Plotting, warning= FALSE, message= FALSE}
#KEGG analysis plots
dotplot(KEGG, showCategory = 8, title = "Enriched Pathways" , split=".sign") + facet_grid(.~.sign)
cnetplot(KEGG, categorySize="pvalue", foldChange=gene_list)

compare_cluster_GO_KEGG <- enrichplot::pairwise_termsim(KEGG, semData = KEGG)
emapplot(compare_cluster_GO_KEGG, showCategory = 10)

```



